diff -uprN ./origin_fbtft/Makefile ./fbtft/Makefile
--- ./origin_fbtft/Makefile	2021-01-16 00:34:40.261283033 +0900
+++ ./fbtft/Makefile	2021-01-16 00:37:32.520328466 +0900
@@ -49,12 +49,12 @@ default: .config
 .config:
 	grep config Kconfig | cut -d' ' -f2 | sed 's@^@CONFIG_@; s@$$@=m@' > .config
 
-install:
-	$(MAKE) -C $(KDIR) M=$$PWD modules_install
+#install:
+#	$(MAKE) -C $(KDIR) M=$$PWD modules_install
 
 
 clean:
-	rm -rf *.o *~ core .depend .*.cmd *.ko *.mod.c .tmp_versions \
+	rm -rf *.o *~ core .depend .*.cmd *.ko *.mod.c *.mod .tmp_versions \
 	       modules.order Module.symvers
 
 endif
diff -uprN ./origin_fbtft/README ./fbtft/README
--- ./origin_fbtft/README	2021-01-16 00:34:40.261283033 +0900
+++ ./fbtft/README	2021-01-16 00:26:46.236918639 +0900
@@ -1,3 +1,16 @@
+#for maji majo Iris LCD
+マジマジョアイリス用のmod です。
+
+
+
+
+
+
+
+
+
+以下、original README
+
   FBTFT
 =========
 
diff -uprN ./origin_fbtft/fb_s6d1121.c ./fbtft/fb_s6d1121.c
--- ./origin_fbtft/fb_s6d1121.c	2021-01-16 00:34:40.271282977 +0900
+++ ./fbtft/fb_s6d1121.c	2021-01-16 02:43:44.599252061 +0900
@@ -1,11 +1,13 @@
 /*
- * FB driver for the S6D1121 LCD Controller
+ * FB driver for the ILI9341  LCD display controller
  *
- * Copyright (C) 2013 Roman Rolinsky
+ * This display uses 9-bit SPI: Data/Command bit + 8 data bits
+ * For platforms that doesn't support 9-bit, the driver is capable
+ * of emulating this using 8-bit transfer.
+ * This is done by transfering eight 9-bit words in 9 bytes.
  *
- * Based on fb_ili9325.c by Noralf Tronnes
- * Based on ili9325.c by Jeroen Domburg
- * Init code from UTFT library by Henning Karlsen
+ * Copyright (C) 2013 Christian Vogelgsang
+ * Based on adafruit22fb.c by Noralf Tronnes
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -22,21 +24,32 @@
  * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
  */
 
+
+
+//mod by devemin
+//fbtft_devicename : s6d1121.c referd.
+//execution code : ili9341 refered.
+
+
+//This is for Maji Majo Pures LCD !
+
+
+
 #include <linux/module.h>
 #include <linux/kernel.h>
 #include <linux/init.h>
-#include <linux/gpio.h>
 #include <linux/delay.h>
 
 #include "fbtft.h"
 
 #define DRVNAME		"fb_s6d1121"
-#define WIDTH		240
-#define HEIGHT		320
-#define BPP		16
-#define FPS		20
-#define DEFAULT_GAMMA	"26 09 24 2C 1F 23 24 25 22 26 25 23 0D 00\n" \
-			"1C 1A 13 1D 0B 11 12 10 13 15 36 19 00 0D"
+#define WIDTH		640
+#define HEIGHT		48
+#define TXBUFLEN	(2 * PAGE_SIZE)
+#define DEFAULT_GAMMA	"00 1C 21 02 11 07 3D 79 4B 07 0F 0C 1B 1F 0F\n" \
+			"00 1C 20 04 0F 04 33 45 42 04 0C 0A 22 29 0F"
+
+
 
 static int init_display(struct fbtft_par *par)
 {
@@ -44,42 +57,40 @@ static int init_display(struct fbtft_par
 
 	par->fbtftops.reset(par);
 
-	if (par->gpio.cs != -1)
-		gpio_set_value(par->gpio.cs, 0);  /* Activate chip */
-
-	/* Initialization sequence from Lib_UTFT */
+	/* startup sequence for Maji Majo Pures LCD */
 
-	write_reg(par, 0x0011, 0x2004);
-	write_reg(par, 0x0013, 0xCC00);
-	write_reg(par, 0x0015, 0x2600);
-	write_reg(par, 0x0014, 0x252A);
-	write_reg(par, 0x0012, 0x0033);
-	write_reg(par, 0x0013, 0xCC04);
-	write_reg(par, 0x0013, 0xCC06);
-	write_reg(par, 0x0013, 0xCC4F);
-	write_reg(par, 0x0013, 0x674F);
-	write_reg(par, 0x0011, 0x2003);
-	write_reg(par, 0x0016, 0x0007);
-	write_reg(par, 0x0002, 0x0013);
-	write_reg(par, 0x0003, 0x0003);
-	write_reg(par, 0x0001, 0x0127);
-	write_reg(par, 0x0008, 0x0303);
-	write_reg(par, 0x000A, 0x000B);
-	write_reg(par, 0x000B, 0x0003);
-	write_reg(par, 0x000C, 0x0000);
-	write_reg(par, 0x0041, 0x0000);
-	write_reg(par, 0x0050, 0x0000);
-	write_reg(par, 0x0060, 0x0005);
-	write_reg(par, 0x0070, 0x000B);
-	write_reg(par, 0x0071, 0x0000);
-	write_reg(par, 0x0078, 0x0000);
-	write_reg(par, 0x007A, 0x0000);
-	write_reg(par, 0x0079, 0x0007);
-	write_reg(par, 0x0007, 0x0051);
-	write_reg(par, 0x0007, 0x0053);
-	write_reg(par, 0x0079, 0x0000);
-
-	write_reg(par, 0x0022); /* Write Data to GRAM */
+	//write_reg(par, 0x01); /* software reset */
+	//mdelay(5);
+	//write_reg(par, 0x28); /* display off */
+
+	/* --------------------------------------------------------- */
+    // Set EXTC
+	write_reg(par, 0xC8, 0xFF, 0x93, 0x42);
+    // Column Address Set
+	write_reg(par, 0x2A, 0x00, 0x00, 0x01, 0x3F);
+    // Page Address Set
+	write_reg(par, 0x2B, 0x00, 0x00, 0x00, 0x5F);
+    // Memory Access Control
+	write_reg(par, 0x36, 0xC8);
+	/* ------------power control-------------------------------- */
+    // Power Control 1
+	write_reg(par, 0xC0, 0x0E, 0x0E);
+    // Power Control 2
+	write_reg(par, 0xC1, 0x10);
+	/* ------------VCOM --------- */
+	write_reg(par, 0xC5, 0xFA);
+    // Pixel Format Set
+	/* ------------memory access control------------------------ */
+	write_reg(par, 0x3A, 0x55); /* 16bit pixel */
+	/* ------------frame rate----------------------------------- */
+	write_reg(par, 0xB1, 0x00, 0x18);
+	/* ------------Gamma---------------------------------------- */
+	/* ------------display-------------------------------------- */
+
+	write_reg(par, 0x11); /* sleep out */
+	mdelay(130);
+	write_reg(par, 0x29); /* display on */
+	mdelay(10);
 
 	return 0;
 }
@@ -88,46 +99,46 @@ static void set_addr_win(struct fbtft_pa
 {
 	fbtft_par_dbg(DEBUG_SET_ADDR_WIN, par,
 		"%s(xs=%d, ys=%d, xe=%d, ye=%d)\n", __func__, xs, ys, xe, ye);
-	switch (par->info->var.rotate) {
-	/* R20h = Horizontal GRAM Start Address */
-	/* R21h = Vertical GRAM Start Address */
-	case 0:
-		write_reg(par, 0x0020, xs);
-		write_reg(par, 0x0021, ys);
-		break;
-	case 180:
-		write_reg(par, 0x0020, WIDTH - 1 - xs);
-		write_reg(par, 0x0021, HEIGHT - 1 - ys);
-		break;
-	case 270:
-		write_reg(par, 0x0020, WIDTH - 1 - ys);
-		write_reg(par, 0x0021, xs);
-		break;
-	case 90:
-		write_reg(par, 0x0020, ys);
-		write_reg(par, 0x0021, HEIGHT - 1 - xs);
-		break;
-	}
-	write_reg(par, 0x0022); /* Write Data to GRAM */
+
+	xe = 319;
+	ye = 95;
+
+	/* Column address set */
+	write_reg(par, 0x2A,
+		(xs >> 8) & 0xFF, xs & 0xFF, (xe >> 8) & 0xFF, xe & 0xFF);
+
+	/* Row adress set */
+	write_reg(par, 0x2B,
+		(ys >> 8) & 0xFF, ys & 0xFF, (ye >> 8) & 0xFF, ye & 0xFF);
+
+	/* Memory write */
+	write_reg(par, 0x2C);
 }
 
+#define MEM_Y   (7) /* MY row address order */
+#define MEM_X   (6) /* MX column address order */
+#define MEM_V   (5) /* MV row / column exchange */
+#define MEM_L   (4) /* ML vertical refresh order */
+#define MEM_H   (2) /* MH horizontal refresh order */
+#define MEM_BGR (3) /* RGB-BGR Order */
 static int set_var(struct fbtft_par *par)
 {
 	fbtft_par_dbg(DEBUG_INIT_DISPLAY, par, "%s()\n", __func__);
 
 	switch (par->info->var.rotate) {
-	/* AM: GRAM update direction */
 	case 0:
-		write_reg(par, 0x03, 0x0003 | (par->bgr << 12));
-		break;
-	case 180:
-		write_reg(par, 0x03, 0x0000 | (par->bgr << 12));
+		write_reg(par, 0x36, (1 << MEM_X) | (par->bgr << MEM_BGR));
 		break;
 	case 270:
-		write_reg(par, 0x03, 0x000A | (par->bgr << 12));
+		write_reg(par, 0x36,
+			(1<<MEM_V) | (1 << MEM_L) | (par->bgr << MEM_BGR));
+		break;
+	case 180:
+		write_reg(par, 0x36, (1 << MEM_Y) | (par->bgr << MEM_BGR));
 		break;
 	case 90:
-		write_reg(par, 0x03, 0x0009 | (par->bgr << 12));
+		write_reg(par, 0x36, (1 << MEM_Y) | (1 << MEM_X) |
+				     (1 << MEM_V) | (par->bgr << MEM_BGR));
 		break;
 	}
 
@@ -136,44 +147,23 @@ static int set_var(struct fbtft_par *par
 
 /*
   Gamma string format:
-    PKP0 PKP1 PKP2 PKP3 PKP4 PKP5 PKP6 PKP7 PKP8 PKP9 PKP10 PKP11 VRP0 VRP1
-    PKN0 PKN1 PKN2 PKN3 PKN4 PKN5 PKN6 PKN7 PRN8 PRN9 PRN10 PRN11 VRN0 VRN1
+    Positive: Par1 Par2 [...] Par15
+    Negative: Par1 Par2 [...] Par15
 */
 #define CURVE(num, idx)  curves[num*par->gamma.num_values + idx]
 static int set_gamma(struct fbtft_par *par, unsigned long *curves)
 {
-	unsigned long mask[] = {
-		0b111111, 0b111111, 0b111111, 0b111111, 0b111111, 0b111111, 
-		0b111111, 0b111111, 0b111111, 0b111111, 0b111111, 0b111111,
-		0b11111, 0b11111,
-		0b111111, 0b111111, 0b111111, 0b111111, 0b111111, 0b111111,
-		0b111111, 0b111111, 0b111111, 0b111111, 0b111111, 0b111111,
-		0b11111, 0b11111 };
-	int i, j;
+	int i;
 
 	fbtft_par_dbg(DEBUG_INIT_DISPLAY, par, "%s()\n", __func__);
 
-	/* apply mask */
-	for (i = 0; i < 2; i++)
-		for (j = 0; j < 14; j++)
-			CURVE(i, j) &= mask[i*par->gamma.num_values + j];
-
-	write_reg(par, 0x0030, CURVE(0, 1) << 8 | CURVE(0, 0));
-	write_reg(par, 0x0031, CURVE(0, 3) << 8 | CURVE(0, 2));
-	write_reg(par, 0x0032, CURVE(0, 5) << 8 | CURVE(0, 3));
-	write_reg(par, 0x0033, CURVE(0, 7) << 8 | CURVE(0, 6));
-	write_reg(par, 0x0034, CURVE(0, 9) << 8 | CURVE(0, 8));
-	write_reg(par, 0x0035, CURVE(0, 11) << 8 | CURVE(0, 10));
-
-	write_reg(par, 0x0036, CURVE(1, 1) << 8 | CURVE(1, 0));
-	write_reg(par, 0x0037, CURVE(1, 3) << 8 | CURVE(1, 2));
-	write_reg(par, 0x0038, CURVE(1, 5) << 8 | CURVE(1, 4));
-	write_reg(par, 0x0039, CURVE(1, 7) << 8 | CURVE(1, 6));
-	write_reg(par, 0x003A, CURVE(1, 9) << 8 | CURVE(1, 8));
-	write_reg(par, 0x003B, CURVE(1, 11) << 8 | CURVE(1, 10));
-
-	write_reg(par, 0x003C, CURVE(0, 13) << 8 | CURVE(0, 12));
-	write_reg(par, 0x003D, CURVE(1, 13) << 8 | CURVE(1, 12));
+	for (i = 0; i < par->gamma.num_curves; i++)
+		write_reg(par, 0xE0 + i,
+			CURVE(i, 0), CURVE(i, 1), CURVE(i, 2),
+			CURVE(i, 3), CURVE(i, 4), CURVE(i, 5),
+			CURVE(i, 6), CURVE(i, 7), CURVE(i, 8),
+			CURVE(i, 9), CURVE(i, 10), CURVE(i, 11),
+			CURVE(i, 12), CURVE(i, 13), CURVE(i, 14));
 
 	return 0;
 }
@@ -181,19 +171,18 @@ static int set_gamma(struct fbtft_par *p
 
 
 static struct fbtft_display display = {
-	.regwidth = 16,
+	.regwidth = 8,
 	.width = WIDTH,
 	.height = HEIGHT,
-	.bpp = BPP,
-	.fps = FPS,
+	.txbuflen = TXBUFLEN,
 	.gamma_num = 2,
-	.gamma_len = 14,
+	.gamma_len = 15,
 	.gamma = DEFAULT_GAMMA,
 	.fbtftops = {
 		.init_display = init_display,
 		.set_addr_win = set_addr_win,
-		.set_var = set_var,
-		.set_gamma = set_gamma,
+		//.set_var = set_var,
+		//.set_gamma = set_gamma,
 	},
 };
 FBTFT_REGISTER_DRIVER(DRVNAME, "samsung,s6d1121", &display);
@@ -203,6 +192,6 @@ MODULE_ALIAS("platform:" DRVNAME);
 MODULE_ALIAS("spi:s6d1121");
 MODULE_ALIAS("platform:s6d1121");
 
-MODULE_DESCRIPTION("FB driver for the S6D1121 LCD Controller");
-MODULE_AUTHOR("Roman Rolinsky");
+MODULE_DESCRIPTION("FB driver for the S6D1121 LCD display controller");
+MODULE_AUTHOR("Christian Vogelgsang");
 MODULE_LICENSE("GPL");
diff -uprN ./origin_fbtft/fbtft-core.c ./fbtft/fbtft-core.c
--- ./origin_fbtft/fbtft-core.c	2021-01-16 00:34:40.271282977 +0900
+++ ./fbtft/fbtft-core.c	2021-01-16 00:52:24.818352420 +0900
@@ -370,16 +370,17 @@ void fbtft_reset(struct fbtft_par *par)
 void fbtft_update_display(struct fbtft_par *par, unsigned start_line, unsigned end_line)
 {
 	size_t offset, len;
-	struct timespec ts_start, ts_end, ts_fps, ts_duration;
-	long fps_ms, fps_us, duration_ms, duration_us;
+	ktime_t ts_start, ts_end;
 	long fps, throughput;
 	bool timeit = false;
 	int ret = 0;
 
-	if (unlikely(par->debug & (DEBUG_TIME_FIRST_UPDATE | DEBUG_TIME_EACH_UPDATE))) {
-		if ((par->debug & DEBUG_TIME_EACH_UPDATE) || \
-				((par->debug & DEBUG_TIME_FIRST_UPDATE) && !par->first_update_done)) {
-			getnstimeofday(&ts_start);
+	if (unlikely(par->debug & (DEBUG_TIME_FIRST_UPDATE |
+			DEBUG_TIME_EACH_UPDATE))) {
+		if ((par->debug & DEBUG_TIME_EACH_UPDATE) ||
+		    ((par->debug & DEBUG_TIME_FIRST_UPDATE) &&
+		    !par->first_update_done)) {
+			ts_start = ktime_get();
 			timeit = true;
 		}
 	}
@@ -387,25 +388,27 @@ void fbtft_update_display(struct fbtft_p
 	/* Sanity checks */
 	if (start_line > end_line) {
 		dev_warn(par->info->device,
-			"%s: start_line=%u is larger than end_line=%u. Shouldn't happen, will do full display update\n",
-			__func__, start_line, end_line);
+			 "%s: start_line=%u is larger than end_line=%u. Shouldn't happen, will do full display update\n",
+			 __func__, start_line, end_line);
 		start_line = 0;
 		end_line = par->info->var.yres - 1;
 	}
-	if (start_line > par->info->var.yres - 1 || end_line > par->info->var.yres - 1) {
+	if (start_line > par->info->var.yres - 1 ||
+	    end_line > par->info->var.yres - 1) {
 		dev_warn(par->info->device,
-			"%s: start_line=%u or end_line=%u is larger than max=%d. Shouldn't happen, will do full display update\n",
-			__func__, start_line, end_line, par->info->var.yres - 1);
+			 "%s: start_line=%u or end_line=%u is larger than max=%d. Shouldn't happen, will do full display update\n",
+			 __func__, start_line,
+			 end_line, par->info->var.yres - 1);
 		start_line = 0;
 		end_line = par->info->var.yres - 1;
 	}
 
 	fbtft_par_dbg(DEBUG_UPDATE_DISPLAY, par, "%s(start_line=%u, end_line=%u)\n",
-		__func__, start_line, end_line);
+		      __func__, start_line, end_line);
 
 	if (par->fbtftops.set_addr_win)
 		par->fbtftops.set_addr_win(par, 0, start_line,
-				par->info->var.xres-1, end_line);
+				par->info->var.xres - 1, end_line);
 
 	offset = start_line * par->info->fix.line_length;
 	len = (end_line - start_line + 1) * par->info->fix.line_length;
@@ -416,30 +419,21 @@ void fbtft_update_display(struct fbtft_p
 			__func__);
 
 	if (unlikely(timeit)) {
-		getnstimeofday(&ts_end);
-		if (par->update_time.tv_nsec == 0 && par->update_time.tv_sec == 0) {
-			par->update_time.tv_sec = ts_start.tv_sec;
-			par->update_time.tv_nsec = ts_start.tv_nsec;
-		}
-		ts_fps = timespec_sub(ts_start, par->update_time);
-		par->update_time.tv_sec = ts_start.tv_sec;
-		par->update_time.tv_nsec = ts_start.tv_nsec;
-		fps_ms = (ts_fps.tv_sec * 1000) + ((ts_fps.tv_nsec / 1000000) % 1000);
-		fps_us = (ts_fps.tv_nsec / 1000) % 1000;
-		fps = fps_ms * 1000 + fps_us;
+		ts_end = ktime_get();
+		if (!ktime_to_ns(par->update_time))
+			par->update_time = ts_start;
+
+		fps = ktime_us_delta(ts_start, par->update_time);
+		par->update_time = ts_start;
 		fps = fps ? 1000000 / fps : 0;
 
-		ts_duration = timespec_sub(ts_end, ts_start);
-		duration_ms = (ts_duration.tv_sec * 1000) + ((ts_duration.tv_nsec / 1000000) % 1000);
-		duration_us = (ts_duration.tv_nsec / 1000) % 1000;
-		throughput = duration_ms * 1000 + duration_us;
+		throughput = ktime_us_delta(ts_end, ts_start);
 		throughput = throughput ? (len * 1000) / throughput : 0;
 		throughput = throughput * 1000 / 1024;
 
 		dev_info(par->info->device,
-			"Display update: %ld kB/s (%ld.%.3ld ms), fps=%ld (%ld.%.3ld ms)\n",
-			throughput, duration_ms, duration_us,
-			fps, fps_ms, fps_us);
+			 "Display update: %ld kB/s, fps=%ld\n",
+			 throughput, fps);
 		par->first_update_done = true;
 	}
 }
@@ -1041,7 +1035,6 @@ int fbtft_unregister_framebuffer(struct
 {
 	struct fbtft_par *par = fb_info->par;
 	struct spi_device *spi = par->spi;
-	int ret;
 
 	if (spi)
 		spi_set_drvdata(spi, NULL);
@@ -1050,8 +1043,8 @@ int fbtft_unregister_framebuffer(struct
 	if (par->fbtftops.unregister_backlight)
 		par->fbtftops.unregister_backlight(par);
 	fbtft_sysfs_exit(par);
-	ret = unregister_framebuffer(fb_info);
-	return ret;
+	unregister_framebuffer(fb_info);
+	return 0;
 }
 EXPORT_SYMBOL(fbtft_unregister_framebuffer);
 
diff -uprN ./origin_fbtft/fbtft.h ./fbtft/fbtft.h
--- ./origin_fbtft/fbtft.h	2021-01-16 00:34:40.271282977 +0900
+++ ./fbtft/fbtft.h	2021-01-16 00:46:26.709369703 +0900
@@ -251,7 +251,7 @@ struct fbtft_par {
 	} gamma;
 	unsigned long debug;
 	bool first_update_done;
-	struct timespec update_time;
+	ktime_t update_time;
 	bool bgr;
 	void *extra;
 };
diff -uprN ./origin_fbtft/majiinsmod.sh ./fbtft/majiinsmod.sh
--- ./origin_fbtft/majiinsmod.sh	1970-01-01 09:00:00.000000000 +0900
+++ ./fbtft/majiinsmod.sh	2021-01-16 02:47:30.507632557 +0900
@@ -0,0 +1,14 @@
+#!/usr/bin/bash
+
+
+sudo modprobe fb_sys_fops
+sudo modprobe syscopyarea
+sudo modprobe sysfillrect
+sudo modprobe sysimgblt
+
+
+sudo insmod ./fbtft.ko dma
+
+sudo insmod ./fb_s6d1121.ko
+
+sudo insmod ./fbtft_device.ko name=itdb24 fps=20 width=640 height=48 bgr=1 buswidth=8 speed=10000000 gpios=reset:4,dc:3,wr:23,cs:2,db00:5,db01:6,db02:13,db03:19,db04:26,db05:12,db06:16,db07:20
diff -uprN ./origin_fbtft/majirmmod.sh ./fbtft/majirmmod.sh
--- ./origin_fbtft/majirmmod.sh	1970-01-01 09:00:00.000000000 +0900
+++ ./fbtft/majirmmod.sh	2021-01-15 02:34:41.101274700 +0900
@@ -0,0 +1,5 @@
+#!/usr/bin/bash
+
+sudo rmmod fbtft_device
+sudo rmmod fb_s6d1121
+sudo rmmod fbtft
